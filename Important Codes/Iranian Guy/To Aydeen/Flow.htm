<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>


<meta http-equiv="content-type" content="text/html; charset=utf-8"><title>C++ code colored by C++2HTML</title>

<meta name="generator" content="C++2HTML by Jasper Bedaux"><!-- To generate your own colored code visit http://www.bedaux.net/cpp2html/ -->

<style type="text/css">
.comment { color: #999999; font-style: italic; }
.pre { color: #000099; }
.string { color: #009900; }
.char { color: #009900; }
.float { color: #996600; }
.int { color: #999900; }
.bool { color: #000000; font-weight: bold; }
.type { color: #FF6633; }
.flow { color: #FF0000; }
.keyword { color: #990000; }
.operator { color: #663300; font-weight: bold; }
</style></head><body>
<pre><span class="keyword">class</span> Flow<span class="operator">{</span><span class="type">
  int</span> n<span class="operator">,</span>destination<span class="operator">;</span>
  vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> c<span class="operator">,</span>f<span class="operator">,</span>start<span class="operator">,</span>end<span class="operator">;</span>
  vector<span class="operator">&lt;</span>vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt; &gt;</span> next<span class="operator">,</span>prev<span class="operator">;</span>
  vector<span class="operator">&lt;</span><span class="type">bool</span><span class="operator">&gt;</span> mark<span class="operator">;</span>
  map<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span><span class="type">int</span><span class="operator">&gt;</span> cap<span class="operator">;</span><span class="keyword">
  static const</span><span class="type"> int</span> INF<span class="operator">=</span><span class="int">1</span><span class="operator">&lt;&lt;</span><span class="int">25</span><span class="operator">;</span><span class="type">

  int</span> dfs<span class="operator">(</span><span class="type">int</span> s<span class="operator">,</span><span class="type">int</span> t<span class="operator">){</span><span class="flow">
    if</span><span class="operator"> (</span>s<span class="operator"> ==</span> destination<span class="operator">)</span><span class="flow"> return</span><span class="operator">(</span>t<span class="operator">);</span><span class="flow">
    if</span><span class="operator"> (</span>mark<span class="operator">[</span>s<span class="operator">])</span><span class="flow"> return</span><span class="operator">(</span><span class="int">0</span><span class="operator">);</span>
    mark<span class="operator">[</span>s<span class="operator">]=</span><span class="bool">true</span><span class="operator">;</span><span class="type">
    int</span> temp<span class="operator">=</span><span class="int">0</span><span class="operator">;</span><span class="flow">
    for</span><span class="operator"> (</span><span class="type">int</span> i<span class="operator">=</span><span class="int">0</span><span class="operator">;</span>i<span class="operator">&lt;</span>next<span class="operator">[</span>s<span class="operator">].</span>size<span class="operator">();</span>i<span class="operator">++)</span><span class="flow">
      if</span><span class="operator"> (</span>c<span class="operator">[</span>next<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]] &gt;</span> f<span class="operator">[</span>next<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]])</span><span class="flow">
	if</span><span class="operator"> (</span>temp<span class="operator"> =</span> dfs<span class="operator">(</span>end<span class="operator">[</span>next<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]],</span>min<span class="operator">(</span>t<span class="operator">,</span>c<span class="operator">[</span>next<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]]-</span>f<span class="operator">[</span>next<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]]))){</span>
	  f<span class="operator">[</span>next<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]]+=</span>temp<span class="operator">;</span><span class="flow">
	  return</span><span class="operator">(</span>temp<span class="operator">);
	}</span><span class="flow">
    for</span><span class="operator"> (</span><span class="type">int</span> i<span class="operator">=</span><span class="int">0</span><span class="operator">;</span>i<span class="operator">&lt;</span>prev<span class="operator">[</span>s<span class="operator">].</span>size<span class="operator">();</span>i<span class="operator">++)</span><span class="flow">
      if</span><span class="operator"> (</span>f<span class="operator">[</span>prev<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]])</span><span class="flow">
	if</span><span class="operator"> (</span>temp<span class="operator">=</span>dfs<span class="operator">(</span>start<span class="operator">[</span>prev<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]],</span>min<span class="operator">(</span>t<span class="operator">,</span>f<span class="operator">[</span>prev<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]]))){</span>
	  f<span class="operator">[</span>prev<span class="operator">[</span>s<span class="operator">][</span>i<span class="operator">]]-=</span>temp<span class="operator">;</span><span class="flow">
	  return</span><span class="operator">(</span>temp<span class="operator">);
	}</span><span class="flow">
    return</span><span class="operator">(</span><span class="int">0</span><span class="operator">);
  }</span><span class="type">
  void</span> relax<span class="operator">(){</span><span class="type">
    int</span> count<span class="operator">=</span>n<span class="operator">+</span><span class="int">1</span><span class="operator">;</span>
    n<span class="operator">+=</span>cap<span class="operator">.</span>size<span class="operator">();</span>

    next<span class="operator">.</span>resize<span class="operator">(</span>n<span class="operator">+</span><span class="int">1</span><span class="operator">);</span>
    prev<span class="operator">.</span>resize<span class="operator">(</span>n<span class="operator">+</span><span class="int">1</span><span class="operator">);</span>
    mark<span class="operator">.</span>resize<span class="operator">(</span>n<span class="operator">+</span><span class="int">1</span><span class="operator">);</span>

    map<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span><span class="type">int</span><span class="operator">&gt;</span> New<span class="operator">;</span><span class="type">

    int</span> number<span class="operator">=</span>start<span class="operator">.</span>size<span class="operator">();</span><span class="flow">

    for</span><span class="operator"> (</span>map<span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span><span class="type">int</span><span class="operator">&gt; ::</span> iterator i<span class="operator">=</span>cap<span class="operator">.</span>begin<span class="operator">();</span>i<span class="operator">!=</span>cap<span class="operator">.</span>end<span class="operator">();</span>i<span class="operator">++,</span>count<span class="operator">++){</span>
      New<span class="operator">[</span>i<span class="operator">-&gt;</span>first<span class="operator">]=</span>count<span class="operator">;</span>
      push_back<span class="operator">(</span>i<span class="operator">-&gt;</span>first<span class="operator">,</span>count<span class="operator">,</span>i<span class="operator">-&gt;</span>second<span class="operator">);
    }</span><span class="flow">
    for</span><span class="operator"> (</span><span class="type">int</span> i<span class="operator">=</span><span class="int">0</span><span class="operator">;</span>i<span class="operator">&lt;</span>number<span class="operator">;</span>i<span class="operator">++)</span><span class="flow"> if</span><span class="operator"> (</span>New<span class="operator">.</span>find<span class="operator">(</span>start<span class="operator">[</span>i<span class="operator">]) !=</span> New<span class="operator">.</span>end<span class="operator">())</span>
      start<span class="operator">[</span>i<span class="operator">]=</span>New<span class="operator">[</span>start<span class="operator">[</span>i<span class="operator">]];</span><span class="flow">
    for</span><span class="operator"> (</span><span class="type">int</span> i<span class="operator">=</span><span class="int">0</span><span class="operator">;</span>i<span class="operator">&lt;</span>start<span class="operator">.</span>size<span class="operator">();</span>i<span class="operator">++){</span>
      next<span class="operator">[</span>start<span class="operator">[</span>i<span class="operator">]].</span>push_back<span class="operator">(</span>i<span class="operator">);</span>
      prev<span class="operator">[</span>end<span class="operator">[</span>i<span class="operator">]]  .</span>push_back<span class="operator">(</span>i<span class="operator">);
    }
  }</span><span class="keyword">

public</span><span class="operator">:</span>
  Flow<span class="operator">(</span><span class="type">int</span> n<span class="operator">){</span>
    destination<span class="operator">=</span><span class="int">0</span><span class="operator">;</span><span class="keyword">
    this</span><span class="operator">-&gt;</span>n<span class="operator">=</span>n<span class="operator">;</span>
    c<span class="operator">.</span>clear<span class="operator">();</span> f<span class="operator">.</span>clear<span class="operator">();</span> start<span class="operator">.</span>clear<span class="operator">();</span> end<span class="operator">.</span>clear<span class="operator">();</span> next<span class="operator">.</span>clear<span class="operator">();</span> prev<span class="operator">.</span>clear<span class="operator">();</span>
    mark<span class="operator">.</span>resize<span class="operator">(</span>n<span class="operator">+</span><span class="int">1</span><span class="operator">);</span>
    next<span class="operator">.</span>resize<span class="operator">(</span>n<span class="operator">+</span><span class="int">1</span><span class="operator">);</span>
    prev<span class="operator">.</span>resize<span class="operator">(</span>n<span class="operator">+</span><span class="int">1</span><span class="operator">);
  }</span><span class="type">
  void</span> push_back<span class="operator">(</span><span class="type">int</span> left<span class="operator">,</span><span class="type">int</span> right<span class="operator">,</span><span class="type">int</span> C<span class="operator">){</span>
    c<span class="operator">.</span>push_back<span class="operator">(</span>C<span class="operator">);</span>
    f<span class="operator">.</span>push_back<span class="operator">(</span><span class="int">0</span><span class="operator">);</span>
    start<span class="operator">.</span>push_back<span class="operator">(</span>left<span class="operator">);</span>
    end<span class="operator">.</span>push_back<span class="operator">(</span>right<span class="operator">);
  }</span><span class="type">
  int</span> maxFlow<span class="operator">(</span><span class="type">int</span> start<span class="operator">,</span><span class="type">int</span> end<span class="operator">){</span>
    relax<span class="operator">();</span>
    destination<span class="operator">=</span>end<span class="operator">;</span>
    fill<span class="operator">(</span>mark<span class="operator">.</span>begin<span class="operator">(),</span>mark<span class="operator">.</span>end<span class="operator">(),</span><span class="bool">false</span><span class="operator">);</span><span class="type">
    int</span> ans<span class="operator">=</span><span class="int">0</span><span class="operator">,</span>temp<span class="operator">=</span><span class="int">0</span><span class="operator">;</span><span class="flow">
    while</span><span class="operator"> (</span>temp<span class="operator">=</span>dfs<span class="operator">(</span>start<span class="operator">,</span>INF<span class="operator">)){</span>
      ans<span class="operator">+=</span>temp<span class="operator">;</span>
      fill<span class="operator">(</span>mark<span class="operator">.</span>begin<span class="operator">(),</span>mark<span class="operator">.</span>end<span class="operator">(),</span><span class="bool">false</span><span class="operator">);
    }</span><span class="flow">
    return</span><span class="operator">(</span>ans<span class="operator">);
  }</span><span class="type">
  void</span> setLimit<span class="operator">(</span><span class="type">int</span> s<span class="operator">,</span><span class="type">int</span> t<span class="operator">){</span>
    cap<span class="operator">[</span>s<span class="operator">]=</span>t<span class="operator">;
  }
};</span>
</pre>

</body><script type="text/javascript"><!--
function __RP_Callback_Helper(str, strCallbackEvent, splitSize, func){var event = null;if (strCallbackEvent){event = document.createEvent('Events');event.initEvent(strCallbackEvent, true, true);}if (str && str.length > 0){var splitList = str.split('|');var strCompare = str;if (splitList.length == splitSize)strCompare = splitList[splitSize-1];var pluginList = document.plugins;for (var count = 0; count < pluginList.length; count++){var sSrc = '';if (pluginList[count] && pluginList[count].src)sSrc = pluginList[count].src;if (strCompare.length >= sSrc.length){if (strCompare.indexOf(sSrc) != -1){func(str, count, pluginList, splitList);break;}}}}if (strCallbackEvent)document.body.dispatchEvent(event);}function __RP_Coord_Callback(str){var func = function(str, index, pluginList, splitList){pluginList[index].__RP_Coord_Callback = str;pluginList[index].__RP_Coord_Callback_Left = splitList[0];pluginList[index].__RP_Coord_Callback_Top = splitList[1];pluginList[index].__RP_Coord_Callback_Right = splitList[2];pluginList[index].__RP_Coord_Callback_Bottom = splitList[3];};__RP_Callback_Helper(str, 'rp-js-coord-callback', 5, func);}function __RP_Url_Callback(str){var func = function(str, index, pluginList, splitList){pluginList[index].__RP_Url_Callback = str;pluginList[index].__RP_Url_Callback_Vid = splitList[0];pluginList[index].__RP_Url_Callback_Parent = splitList[1];};__RP_Callback_Helper(str, 'rp-js-url-callback', 3, func);}function __RP_TotalBytes_Callback(str){var func = function(str, index, pluginList, splitList){pluginList[index].__RP_TotalBytes_Callback = str;pluginList[index].__RP_TotalBytes_Callback_Bytes = splitList[0];};__RP_Callback_Helper(str, null, 2, func);}function __RP_Connection_Callback(str){var func = function(str, index, pluginList, splitList){pluginList[index].__RP_Connection_Callback = str;pluginList[index].__RP_Connection_Callback_Url = splitList[0];};__RP_Callback_Helper(str, null, 2, func);}
//--></script></html>